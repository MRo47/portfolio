<!DOCTYPE html>
<html>
	<head>
		<title>Work detail</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="format-detection" content="telephone=no">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<!-- Fonts-->
		<link rel="stylesheet" type="text/css" href="assets/fonts/fontawesome/font-awesome.min.css">
		<link rel="stylesheet" type="text/css" href="assets/fonts/pe-icon/pe-icon.css">
		<!-- Vendors-->
		<link rel="stylesheet" type="text/css" href="assets/vendors/bootstrap/grid.css">
		<link rel="stylesheet" type="text/css" href="assets/vendors/magnific-popup/magnific-popup.min.css">
		<link rel="stylesheet" type="text/css" href="assets/vendors/swiper/swiper.css">
		<!-- App & fonts-->
		<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Montserrat:300,400,500,600,700|Open+Sans:400,700">
		<link rel="stylesheet" type="text/css" id="app-stylesheet" href="assets/css/main.css"><!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
		<![endif]-->
	</head>
	
	<body>
		<div class="page-wrap" id="root">
			
			<!-- header -->
			<header class="header header--fixed">
				<div class="header__inner">
					<div class="header__logo"><a href="index.html"><img src="assets/img/logo.png" alt="" style="width: 300px;"/></a></div>
					<div class="navbar-toggle" id="fs-button">
						<div class="navbar-icon"><span></span></div>
					</div>
				</div>
				
				<!-- fullscreenmenu__module -->
				<div class="fullscreenmenu__module" trigger="#fs-button">
					
					<!-- overlay-menu -->
					<nav class="overlay-menu">
						
						<!--  -->
						<ul class="wil-menu-list">
							<li><a href="index.html">Home</a>
							</li>
							<li><a href="about.html">About</a>
							</li>
							<li><a href="work.html">Work</a>
							</li>
							<!-- <li><a href="blog.html">Blog</a>
							</li> -->
							<li><a href="contact.html">Contact</a>
							</li>
						</ul><!--  -->
						
					</nav><!-- End / overlay-menu -->
					
				</div><!-- End / fullscreenmenu__module -->
				
			</header><!-- End / header -->
			
			<!-- Content-->
			<div class="wil-content">
				
				<!-- Section -->
				<section class="awe-section">
					<div class="container">
						
						<!-- page-title -->
						<div class="page-title pb-40">
							<h2 class="page-title__title">Kalman Filter</h2>
							<p class="page-title__text">A comprehensive 2D <a href="https://en.wikipedia.org/wiki/Rudolf_E._K%C3%A1lm%C3%A1n">Kalman</a> filter tutorial for self<sub>t+dt</sub> and any explorer from space time.</p>
							<div class="page-title__divider"></div>
						</div><!-- End / page-title -->
						
					</div>
				</section>
				<!-- End / Section -->
				
				
				<!-- Section -->
				<section class="awe-section bg-gray">
					<div class="container">
						
						<!--  -->
						<div>
							<div class="work-detail__entry">
								<center>
									<a href="https://www.farmersalmanac.com/the-truth-behind-in-like-a-lion-out-like-a-lamb-2867"><img src="assets/img/works/lion1.jpeg"
											alt=""></a>
									<!-- <div class="work-img">
										
									</div> -->
									<h5 id="wall">A beautiful picture of a lion laughing (maybe) which makes absolutely no sense at all here, just like kalman filter 
										did to me before I decided to write this guide</h5>
								</center>
								<p>
									<h3>Objectives</h3> 
									<ul style="list-style-type: disc">
										<li> To understand the intuition behind kalman filters.</li>
										<li> To design a kalman filter to track the position and orientation of an object moving on a 2D plane with 3
										degrees of freedom (translation in x, translation in y and rotation along z or yaw).</li>
										<li> To understand sensor fusion using
										kalman filters.</li>
										<li> To be able to design application specific kalman filters.</li>
									</ul>
								</p>
								<!-- <center>
									<div class="work-img">
										<img src="assets/img/works/KF_fusion_anim.gif" alt="">
									</div>
									<h5 id="block-diagram-of-kalman-filter">Block diagram of kalman filter</h5>
								</center> -->
								


								<h3>Gaussian distribution and product of 2 gaussian PDFs</h3>
								<p>Before we dive in, lets understand how probability distribution functions (PDFs) work, which form the basis of the mathematics we will be
									looking later in this article
								</p>
								<p>For 2 <a href="https://en.wikipedia.org/wiki/Normal_distribution"> normally (Gaussian) </a> 
									distributed functions we define the probability density functions with means 
									<img src="https://render.githubusercontent.com/render/math?math=\mu_1, \mu_2">
									and variances 
									<img src="https://render.githubusercontent.com/render/math?math=\sigma_1^2, \sigma_2^2">
								</p>
								<p>the mean in our case is the position where we expect the robot to be, while the variance signifies how far the spread of this value is.</p>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;\newline&space;x_1(t)&space;=&space;\frac{1}{\sqrt{2\pi\sigma_1^2}}e^{-\frac{(t-\mu_1)^2}{2\sigma_1^2}}&space;\\&space;\newline&space;x_2(t)&space;=&space;\frac{1}{\sqrt{2\pi\sigma_2^2}}e^{-\frac{(t-\mu_2)^2}{2\sigma_2^2}}"
										title="\newline x_1(t) = \frac{1}{\sqrt{2\pi\sigma_1^2}}e^{-\frac{(t-\mu_1)^2}{2\sigma_1^2}} \\ \newline x_2(t) = \frac{1}{\sqrt{2\pi\sigma_2^2}}e^{-\frac{(t-\mu_2)^2}{2\sigma_2^2}}" />
								</center>
								<br>
								<p>The product density of the above function will have mean and variance given as</p>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;\newline&space;\mu&space;=&space;\frac{\frac{\mu_1}{2\sigma_1^2}&space;&plus;&space;\frac{\mu_2}{2\sigma_2^2}}{\frac{1}{2\sigma_1^2}&space;&plus;&space;\frac{1}{2\sigma_2^2}}&space;=&space;\frac{\mu_1\sigma_2^2&space;&plus;&space;\mu_2\sigma_1^2}{\sigma_2^2&space;&plus;&space;\sigma_1^2}&space;\\&space;\newline&space;\newline&space;\sigma^2&space;=&space;\sigma_1^2&space;\sigma_2^2&space;=&space;\frac{1}{\frac{1}{\sigma_1^2}&space;&plus;&space;\frac{1}{\sigma_2^2}}&space;=&space;\frac{\sigma_1^2\sigma_2^2}{\sigma_1^2&space;&plus;&space;\sigma_2^2}"
										title="\newline \mu = \frac{\frac{\mu_1}{2\sigma_1^2} + \frac{\mu_2}{2\sigma_2^2}}{\frac{1}{2\sigma_1^2} + \frac{1}{2\sigma_2^2}} = \frac{\mu_1\sigma_2^2 + \mu_2\sigma_1^2}{\sigma_2^2 + \sigma_1^2} \\ \newline \newline \sigma^2 = \sigma_1^2 \sigma_2^2 = \frac{1}{\frac{1}{\sigma_1^2} + \frac{1}{\sigma_2^2}} = \frac{\sigma_1^2\sigma_2^2}{\sigma_1^2 + \sigma_2^2}" />
								</center>
								<br>
								<p>we use these equations to correct the predicted value by the system dynamic model using the measurement as depicted in the graph below</p>
								<center>
									<div class="work-img">
										<img src="assets/img/works/gaussian_math_marked.png" alt="">
									</div>
									<h5 id="gauss_math">State estimation using gaussian distribution</h5>
								</center>
								<p>The product of 2 gaussians (predicted with mean at 8.0 and measurement with mean at 10.0) gives us the resultant corrected value which is centered 
									at mean = 9.154 and has a less spread (variance) than both the gaussians. This is how we correct the state of the measured variable 
									when a new measurement is available and predict the next state using the system dynamic model which will be discussed later. Refer this 
									video from mathworks on <a href="https://www.mathworks.com/videos/understanding-kalman-filters-part-3-optimal-state-estimator--1490710645421.html">
									understanding kalman filters</a> to have a clearer picture of this concept. 
								</p>
								
								

								<h3 id="algorithm">Algorithm</h3>
								<p>In this section we will look at the functional block diagram of kalman filters.</p>
								<center>
									<div class="work-img">
										<img src="assets/img/works/KalmanFilterBlockD.png" alt="">
									</div>
									<h5 id="block-diagram-of-kalman-filter">Block diagram of kalman filter</h5>
								</center>
								<ol>
									<li>The <b>initial state</b> of the system is given as the first input to the kalman filter.
										<img src="https://render.githubusercontent.com/render/math?math=X_0"> is the state with position, velocity
										and/or acceleration values.
										Which can be set to all 0 if not known. <img src="https://render.githubusercontent.com/render/math?math=P_0"> is
										the initial
										system noise and the diagonals are set to very high values if the state is not known accurately. The intuition
										is that we declare
										the system state (position and velocity) is zero but we are highly uncertain about our estimate and hence the
										high covariance values
										in the <img src="https://render.githubusercontent.com/render/math?math=P"> matrix.
									</li>
									<li>The <b>first input</b> then becomes the <b>prior</b> knowledge of state in the kalman filter and will be updated
										continuously as new measurements come into the system.
									</li>
									<li>The <b>prediction</b> step predicts the next state of the system given the current state. The system noise is
										added to the
										<img src="https://render.githubusercontent.com/render/math?math=P"> matrix at this stage.
									</li>
									<li><b>Measurements</b> are then used to <b>correct</b> the system state using the kalman gain computed using the
										system and
										sensor noise matrices. The noise estimate now is also updated and will reduce if a high kalman gain was
										obtained.
									</li>
									<li>The newly corrected state and noise estimate now can be <b>observed</b> as the new position of the system
										(robot) and
										in unit time will become the prior for predicting the next state of the system. This process continues till the
										system runs and
										new measurements are taken in from the sensors.
									</li>
								</ol>

								<p>Now that we have a roadmap to what we want to achieve lets get deeper into the math. The following sections will
									explain how the system and sensors are modelled before we apply the kalman filter equations.</p>

								
								

								<h3 id="motion-modelling">Dynamic model</h3>
								<p>The following <a href="https://en.wikipedia.org/wiki/Equations_of_motion">equations of motion</a> describe the motion
									of the object with acceptable accuracy (neglecting the higher order differentials of the <a
										href="https://en.wikipedia.org/wiki/Taylor_series">Taylor series</a> approximation like jerk (literally!)).</p>
								<p>the position of the object in unit time (t+1) given the velocity and acceleration can be predicted as...</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;\begin{align*}&space;\newline&space;x_{t&plus;1}&space;&=&space;x_t&space;&plus;&space;t\dot{x}_t&space;&plus;&space;\frac{t^2}{2}\ddot{x}_t&space;\\&space;\newline&space;y_{t&plus;1}&space;&=&space;y_t&space;&plus;&space;t\dot{y}_t&space;&plus;&space;\frac{t^2}{2}\ddot{y}_t&space;\\&space;\newline&space;\theta_{t&plus;1}&space;&=&space;\theta_t&space;&plus;&space;t\dot{\theta}_t&space;&plus;&space;\frac{t^2}{2}\ddot{\theta}_t&space;\\&space;\newline&space;\dot{x}_t&space;=&space;\frac{dx_t}{dt}&space;&=&space;\text{Object&space;velocity&space;along&space;x&space;at&space;time&space;t}&space;\\&space;\newline&space;\ddot{x}_t&space;=&space;\frac{d^2x_t}{dt^2}&space;&=&space;\text{Object&space;acceleration&space;along&space;x&space;at&space;time&space;t}&space;\\&space;\end{align*}"
										title="\begin{align*} \newline x_{t+1} &= x_t + t\dot{x}_t + \frac{t^2}{2}\ddot{x}_t \\ \newline y_{t+1} &= y_t + t\dot{y}_t + \frac{t^2}{2}\ddot{y}_t \\ \newline \theta_{t+1} &= \theta_t + t\dot{\theta}_t + \frac{t^2}{2}\ddot{\theta}_t \\ \newline \dot{x}_t = \frac{dx_t}{dt} &= \text{Object velocity along x at time t} \\ \newline \ddot{x}_t = \frac{d^2x_t}{dt^2} &= \text{Object acceleration along x at time t} \\ \end{align*}" />
									</p>
								</center>
								<p>the velocity can be estimated as...</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;\newline&space;\dot{x}_{t&plus;1}&space;=&space;\dot{x}_t&space;&plus;&space;t\ddot{x}_{t}&space;\\&space;\newline&space;\dot{y}_{t&plus;1}&space;=&space;\dot{y}_t&space;&plus;&space;t\ddot{y}_{t}&space;\\&space;\newline&space;\dot{\theta}_{t&plus;1}&space;=&space;\dot{\theta}_t&space;&plus;&space;t\ddot{\theta}_{t}&space;\\"
											title="\large \newline \dot{x}_{t+1} = \dot{x}_t + t\ddot{x}_{t} \\ \newline \dot{y}_{t+1} = \dot{y}_t + t\ddot{y}_{t} \\ \newline \dot{\theta}_{t+1} = \dot{\theta}_t + t\ddot{\theta}_{t} \\" />
									</p>
								</center>

								<p>The above motion equations can be represented as a <b>system dynamics</b> matrix. 
									The <b>system state</b> in this case is the <b>position</b> (x, y,
									orientation or heading angle which is 0 if heading parallel to x axis) and <b>velocity</b> (linear along x and y, angular along z)
								</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;X_{n&plus;1}&space;=&space;\begin{bmatrix}&space;x_{n&plus;1}&space;\\&space;y_{n&plus;1}&space;\\&space;\theta_{n&plus;1}&space;\\&space;\dot{x}_{n&plus;1}&space;\\&space;\dot{y}_{n&plus;1}&space;\\&space;\dot{\theta}_{n&plus;1}&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;\end{bmatrix}&space;\begin{bmatrix}&space;x_{n}&space;\\&space;y_{n}&space;\\&space;\theta_{n}&space;\\&space;\dot{x}_{n}&space;\\&space;\dot{y}_{n}&space;\\&space;\dot{\theta}_{n}&space;\end{bmatrix}&space;&plus;&space;\begin{bmatrix}&space;\frac{t^2}{2}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;\\&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;t&space;\end{bmatrix}&space;\begin{bmatrix}&space;\ddot{x}_n&space;\\&space;\ddot{y}_n&space;\\&space;\ddot{\theta}_n&space;\end{bmatrix}"
											title="\large X_{n+1} = \begin{bmatrix} x_{n+1} \\ y_{n+1} \\ \theta_{n+1} \\ \dot{x}_{n+1} \\ \dot{y}_{n+1} \\ \dot{\theta}_{n+1} \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 & t & 0 & 0 \\ 0 & 1 & 0 & 0 & t & 0 \\ 0 & 0 & 1 & 0 & 0 & t \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x_{n} \\ y_{n} \\ \theta_{n} \\ \dot{x}_{n} \\ \dot{y}_{n} \\ \dot{\theta}_{n} \end{bmatrix} + \begin{bmatrix} \frac{t^2}{2} & 0 & 0 \\ 0 & \frac{t^2}{2} & 0 \\ 0 & 0 & \frac{t^2}{2} \\ t & 0 & 0 \\ 0 & t & 0 \\ 0 & 0 & t \end{bmatrix} \begin{bmatrix} \ddot{x}_n \\ \ddot{y}_n \\ \ddot{\theta}_n \end{bmatrix}" />
									</p>
								</center>
								<p>This state space representation can be equated as...</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;X_{n&plus;1}&space;=&space;AX_n&space;&plus;&space;BU_n&space;&plus;&space;w"
											title="\large X_{n+1} = AX_n + BU_n + w" /></p>
									<p>where</p>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;A&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;\end{bmatrix}&space;\text{&space;}&space;B&space;=&space;\begin{bmatrix}&space;\frac{t^2}{2}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;\\&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;t&space;\end{bmatrix}"
											title="\large A = \begin{bmatrix} 1 & 0 & 0 & t & 0 & 0 \\ 0 & 1 & 0 & 0 & t & 0 \\ 0 & 0 & 1 & 0 & 0 & t \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix} \text{ } B = \begin{bmatrix} \frac{t^2}{2} & 0 & 0 \\ 0 & \frac{t^2}{2} & 0 \\ 0 & 0 & \frac{t^2}{2} \\ t & 0 & 0 \\ 0 & t & 0 \\ 0 & 0 & t \end{bmatrix}" />
									</p>
								</center>
								<p>Matrix <img src="https://render.githubusercontent.com/render/math?math=A"> is the system dynamics matrix that aids in
									predicting the next state of the kalman filter given the current state. Matrix <img
										src="https://render.githubusercontent.com/render/math?math=B"> is the control input model and matrix <img
										src="https://render.githubusercontent.com/render/math?math=U"> is the control vector. If the system has any
									control inputs they can be modelled in these matrices to predict the next state and accordingly Q (described below) 
									should be updated to account for the noise input (eg: A gas pedal could be given as a control input to estimate the
									acceleration in which case the B matrix remains as is, since acceleration is given as input).</p>
								<p><img src="https://render.githubusercontent.com/render/math?math=w"> represents the uncertainty or noise in the
									estimate of the system state as we exclude the higher order differentials in the system.</p>



								<h3 id="process-noise">Process noise</h3>
								<p>The process noise <img src="https://render.githubusercontent.com/render/math?math=w"> is the noise which arises due to linearisation
								of the system model using the <a href="https://en.wikipedia.org/wiki/Taylor_series">Taylor series</a> expansion and causes error 
								in prediction of system state given the current state. If accounting for a control input this noise will also represent the noise due
								to external factors on the system (eg: road friction and air drag on a car). Process noise can be modelled as an equation.
								</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;Q&space;=&space;BQ_aB^T"
											title="\large Q = BQ_aB^T" /></p>
								</center>
								<p>where <img src="https://render.githubusercontent.com/render/math?math=Q_a"> is the uncertainty or noise in the
									acceleration given as variance (square of standard deviation) of acceleration.
								</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;Q_a&space;=&space;\begin{bmatrix}&space;\sigma_{\ddot{x}}^2&space;&&space;\sigma_{\ddot{y}}.\sigma_{\ddot{x}}&space;&&space;\sigma_{\ddot{\theta}}.\sigma_{\ddot{y}}&space;\\&space;\sigma_{\ddot{x}}.\sigma_{\ddot{y}}&space;&&space;\sigma_{\ddot{y}}^2&space;&&space;\sigma_{\ddot{\theta}}.\sigma_{\ddot{y}}&space;\\&space;\sigma_{\ddot{x}}.\sigma_{\ddot{\theta}}&space;&&space;\sigma_{\ddot{y}}.\sigma_{\ddot{\theta}}&space;&&space;\sigma_{\ddot{\theta}}^2&space;\end{bmatrix}"
											title="\large Q_a = \begin{bmatrix} \sigma_{\ddot{x}}^2 & \sigma_{\ddot{y}}.\sigma_{\ddot{x}} & \sigma_{\ddot{\theta}}.\sigma_{\ddot{y}} \\ \sigma_{\ddot{x}}.\sigma_{\ddot{y}} & \sigma_{\ddot{y}}^2 & \sigma_{\ddot{\theta}}.\sigma_{\ddot{y}} \\ \sigma_{\ddot{x}}.\sigma_{\ddot{\theta}} & \sigma_{\ddot{y}}.\sigma_{\ddot{\theta}} & \sigma_{\ddot{\theta}}^2 \end{bmatrix}" />
									</p>
								</center>
								<p>The matrix diagonals represent the <a href="https://en.wikipedia.org/wiki/Variance">variance</a> (noise) in each predicted variable. 
									The non diagonal values in the matrix represent the <a href=https://en.wikipedia.org/wiki/Covariance>covariance</a> between variables 
									(eg: how noise in x is correlated to y is given in row 2 column 1 which is the same as row 1 and column 2).
									Assuming there is no correlation between the noise in acceleration of x to the noise in acceleration of y or <img
										src="https://render.githubusercontent.com/render/math?math=\theta"> we can write <img
										src="https://render.githubusercontent.com/render/math?math=Q_a"> by equating the non diagonal elements to 0.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;Q_a&space;=&space;\begin{bmatrix}&space;\sigma_{\ddot{x}}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{\ddot{y}}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{\ddot{\theta}}^2&space;\end{bmatrix}"
											title="\large Q_a = \begin{bmatrix} \sigma_{\ddot{x}}^2 & 0 & 0 \\ 0 & \sigma_{\ddot{y}}^2 & 0 \\ 0 & 0 & \sigma_{\ddot{\theta}}^2 \end{bmatrix}" />
									</p>
								</center>



								<h3 id="measurement-model">Measurement model</h3>
								Sensors (eg: GPS, imu) are modelled in this section which involves conversion of units or representation (polar to cartesian or cartesian to polar).
								The measurement equation can be written as.
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;Y_{t&plus;1}&space;=&space;H&space;X_{t&plus;1}&space;&plus;&space;V"
											title="\large Y_{t+1} = H X_{t+1} + V" /></p>
								</center>
								<p>The translation matrix <img src="https://render.githubusercontent.com/render/math?math=H"> allows the conversion of
									measurements (eg: units, polar or cartesian form) coming in from sensors to the form represented by the state space model.</p>
								<p>in our case say we have a local gps system that sends us position updates in same units hence the value 1, this value
									will change if we use different units for measurement or if we have another representation of position like polar
									instead of cartesian coordinates.</p>
								<p>the 3 rows indicate that we have 3 measurements x,y,<img src="https://render.githubusercontent.com/render/math?math=\theta">
									coming from our local GPS while the 6 columns represent the states in our system.
									Since we don't measure velocity, these columns have value 0.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;H&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;\end{bmatrix}"
											title="\large H = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 0 & 0\\ 0 & 0 & 1 & 0 & 0 & 0 \end{bmatrix}" />
									</p>
								</center>



								<h3 id="measurement-noise">Measurement noise</h3>
								<center>
									<div class="work-img">
										<img src="assets/img/works/like_a_gauss.jpeg" alt="" width="400">
									</div>
									<h5 id="noise modelling">Thank <a href="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">Carl Friedrich Gauss</a>
										for the bell curve</h5>
								</center>
								<p>As there are no perfect sensors we have to model the noise in the sensors. Sensor noise in kalman filters is assumed
									to be <a href=https://en.wikipedia.org/wiki/Normal_distribution>normally distributed</a> hence is represented by the variance
									or the spread of the value measured by the sensors. Assuming that the measurement noise of the sensors in
									different dimensions is uncorrelated, we set our non diagonal values in the measurement noise matrix to zero.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;R&space;=&space;HH^TV&space;\newline&space;\newline&space;V&space;=&space;\begin{bmatrix}&space;\sigma_{x}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{y}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{{\theta}}^2&space;\end{bmatrix}"
											title="R = HH^TV \newline \newline V = \begin{bmatrix} \sigma_{x}^2 & 0 & 0 \\ 0 & \sigma_{y}^2 & 0 \\ 0 & 0 & \sigma_{{\theta}}^2 \end{bmatrix}" />
									</p>
								</center>
								<p>hence in our case</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;R&space;=&space;\begin{bmatrix}&space;\sigma_{x}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{y}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{{\theta}}^2&space;\end{bmatrix}"
											title="R = \begin{bmatrix} \sigma_{x}^2 & 0 & 0 \\ 0 & \sigma_{y}^2 & 0 \\ 0 & 0 & \sigma_{{\theta}}^2 \end{bmatrix}" />
									</p>
								</center>

								<p>Now that we have modelled our system as well as the measurements coming into it we are ready to plug in our values
									into the kalman filter.</p>
								<p>The algorithm consists of 3 crucial steps: <b>Prediction, gain calculation and update</b></p>
				


								<h3 id="prediction-step">Prediction step</h3>
								<p>The next system state and noise in unit time can be predicted given the current state and system noise as below.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;\newline&space;X_{t&plus;1}&space;=&space;AX_t&space;&plus;&space;BU&space;\\&space;\newline&space;P_{t&plus;1}&space;=&space;AP_tA^{-1}&space;&plus;&space;Q&space;\\"
											title="\large \newline X_{t+1} = AX_t + BU \\ \newline P_{t+1} = AP_tA^{-1} + Q \\" /></p>
								</center>



								<h3 id="kalman-gain-k">Kalman Gain (K)</h3>
								<p>Now we calculate the kalman gain <img src="https://render.githubusercontent.com/render/math?math=K">. This value
									simply represents the proportion in which we should use our measurements versus our prediction to estimate our next
									state.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;K&space;=&space;\frac{P_tH^T}{HP_tH^T&plus;R}"
											title="K = \frac{P_tH^T}{HP_tH^T+R}" /></p>
								</center>
								<p>The denominator for this equation <img src="https://latex.codecogs.com/png.latex?HP_tH^T&plus;R" title="HP_tH^T+R" />
									is also known as the innovation and is denoted as <img
										src="https://render.githubusercontent.com/render/math?math=I"> hence the equation can be written as.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;\newline&space;K&space;=&space;P_tH^TI^{-1}&space;\\&space;\newline&space;I&space;=&space;HP_tH^T&plus;R&space;\\"
											title="\large \newline K = P_tH^TI^{-1} \\ \newline I = HP_tH^T+R \\" /></p>
								</center>
								<p>The general intuition for kalman gain is as the equation below. Higher the noise in measurements the less we trust the
									external measurements w.r.t our predicted state hence lower the gain.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;$K&space;=&space;\frac{\text{System&space;Noise&space;(P)}}{\text{System&space;Noise&space;(P)}&space;&plus;&space;\text{Measurement&space;Noise&space;(R)}&space;}$"
											title="\large $K = \frac{\text{System Noise (P)}}{\text{System Noise (P)} + \text{Measurement Noise (R)} }$" />
									</p>
								</center>



								<h3 id="correction-step">Correction step</h3>
								<p>Here we update our system state using our predictions and measurements.</p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;$X_{t&plus;1}&space;=&space;X_{t&plus;1}&space;&plus;&space;K[Y_{t&plus;1}&space;-&space;HX_{t&plus;1}]$"
											title="\large $X_{t+1} = X_{t+1} + K[Y_{t+1} - HX_{t+1}]$" /></p>
								</center>
								<p>All the step above does is to correct the value we had at prediction state using the kalman gain value we calculated</p>
								<p>Put simply as the <b>weighted average</b> of <b>measurement</b> and <b>prediction</b>. Recall <b>product of 2 PDFs</b></p>
								<center>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;$X_{corrected}&space;=&space;X_{predicted}&space;&plus;&space;K(X_{measured}&space;-&space;X_{predicted})$"
											title="\large $X_{corrected} = X_{predicted} + K(X_{measured} - X_{predicted})$" /></p>
									<p>OR</p>
									<p><img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;$X_{corrected}&space;=&space;K.X_{measured}&space;&plus;&space;(1-K)&space;X_{predicted}$"
											title="\large $X_{corrected} = K.X_{measured} + (1-K) X_{predicted}$" /></p>
								</center>
								<p>The system noise is now corrected as.</p>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;P_{t&plus;1}&space;=&space;(I_6&space;-&space;KH)P_{t&plus;1}"
										title="P_{t+1} = (I_6 - KH)P_{t+1}" />
									<br>
									<p>where</p>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;I_6&space;=&space;\text{Identity&space;matrix&space;of&space;dimensions&space;6X6}"
										title="I_6 = \text{Identity matrix of dimensions 6X6}" />
								</center>

								
								<h3 id="designing-kalman-filters">Designing Kalman Filters</h3>
								<p>Designing an application specific kalman filter involves defining the correct matrices based on the chosen state space
									model and measurement model (sensors).</p>
								
								
								
								<h3 id="kalman-filter-constant-velocity-model">Kalman Filter (Constant velocity model)</h3>
								<p> The equations for kalman filter above will be used in this section to model a simple constant velocity model 
									of kalman filter where we neglect acceleration and higher order terms for linearising the system.
									The only measurement given here will be from a position sensor (like GPS that monitors the robots position in x, y and yaw)
									that has some degree of inaccuracy.</p>
								<p>The design method flows as follows</p>
								<ol style="list-style-type: decimal">
									<li>Here the same dynamic model is used as above (position and velocity)</li>
								</ol>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;X_{n}&space;=&space;\begin{bmatrix}&space;x_{n}&space;\\&space;y_{n}&space;\\&space;\theta_{n}&space;\\&space;\dot{x}_{n}&space;\\&space;\dot{y}_{n}&space;\\&space;\dot{\theta}_{n}&space;\end{bmatrix}"
										title="X_{n} = \begin{bmatrix} x_{n} \\ y_{n} \\ \theta_{n} \\ \dot{x}_{n} \\ \dot{y}_{n} \\ \dot{\theta}_{n} \end{bmatrix}" />
								</center>
								<ol start="2" style="list-style-type: decimal">
									<li>Matrix <img src="https://render.githubusercontent.com/render/math?math=A"> remains the same, matrix <img
											src="https://render.githubusercontent.com/render/math?math=B"> is not used for prediction since we provide
										no control input matrix <img src="https://render.githubusercontent.com/render/math?math=U"></li>
								</ol>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;A&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;\end{bmatrix}&space;\text{&space;}&space;B&space;=&space;\begin{bmatrix}&space;\frac{t^2}{2}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;\\&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;t&space;\end{bmatrix}"
										title="\large A = \begin{bmatrix} 1 & 0 & 0 & t & 0 & 0 \\ 0 & 1 & 0 & 0 & t & 0 \\ 0 & 0 & 1 & 0 & 0 & t \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \end{bmatrix} \text{ } B = \begin{bmatrix} \frac{t^2}{2} & 0 & 0 \\ 0 & \frac{t^2}{2} & 0 \\ 0 & 0 & \frac{t^2}{2} \\ t & 0 & 0 \\ 0 & t & 0 \\ 0 & 0 & t \end{bmatrix}" />
								</center>
								<ol start="3" style="list-style-type: decimal">
									<li>Process noise matrix <img src="https://render.githubusercontent.com/render/math?math=Q"> in this case will be
										due to neglecting acceleration and higher order differentials. It remains the same.</li>
								</ol>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;Q_a&space;=&space;\begin{bmatrix}&space;\sigma_{\ddot{x}}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{\ddot{y}}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{\ddot{\theta}}^2&space;\end{bmatrix}"
										title="\large Q_a = \begin{bmatrix} \sigma_{\ddot{x}}^2 & 0 & 0 \\ 0 & \sigma_{\ddot{y}}^2 & 0 \\ 0 & 0 & \sigma_{\ddot{\theta}}^2 \end{bmatrix}" />
								</center>
								<ol start="4" style="list-style-type: decimal">
									<li>Measurement model needs matrix <img src="https://render.githubusercontent.com/render/math?math=H"> which remains
										the same as above since we have 6 state variables but we measure only 3 variables hence the shape 3x6</li>
								</ol>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\inline&space;\dpi{150}&space;\large&space;H&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;\end{bmatrix}"
										title="\large H = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 0 & 0\\ 0 & 0 & 1 & 0 & 0 & 0 \end{bmatrix}" />
								</center>
								<ol start="5" style="list-style-type: decimal">
									<li>The measurement noise input to the system will be from the position sensor and is modelled as.</li>
								</ol>
								<center>
									<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;R&space;=&space;\begin{bmatrix}&space;\sigma_{x}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{y}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{{\theta}}^2&space;\end{bmatrix}"
										title="R = \begin{bmatrix} \sigma_{x}^2 & 0 & 0 \\ 0 & \sigma_{y}^2 & 0 \\ 0 & 0 & \sigma_{{\theta}}^2 \end{bmatrix}" />
								</center>
								<ol start="6" style="list-style-type: decimal">
									<li>Once the above matrices have been defined the only work that is left is to plug in the values to the kalman
										filter algorithm. The prediction step is run and correction is performed when a measurement is available.</li>
								</ol>



								<h4 id="anim_key">Legend for animations</h4>
								<p>
								The animations that follow show the kalman filters tracking a robot. The points below explain the color schemes 
								and markers used in the plots.
								<ul style="list-style-type: disc">
									<li>
										The <b>green</b> line shows the <b>real
											path</b> the robot followed in the simulation which is a sine curve.
									</li>
									<li>
										The <b>corners on purple lines</b> indicate the <b>measurements</b>
										from the position sensor, the <b>discontinuities</b> in this purple line indicate <b>missing data</b> from the position
										sensor (for mimicking loss
										of signal in GPS or asynchronous data).
									</li>
									<li>
										The <b>red dots</b> indicate the position of robot as <b>predicted</b> by the kalman filter.
									</li>
									<li>
										The <b>arrows</b> for respective plots indicate the <b>orientation</b> of the robot (yaw angle which is zero if the
										robot is parallel
										to the x axis).
									</li>
									<li>
										Be advised that x coordinate in this animation has a linear relationship with time but has noise added hence will jump back
										and forth depending on the value. The y coordinate has a non linear relationship with time and hence the sine curve.
										Refer the modules/datagen.py section on the github repo for the motion model.
									</li>
									<li>
										Plots later in this guide will have acceleration in x, y and theta and indicate the acceleration estimate
										of each variable at some timestamp. This plots are not given for the constant velocity model as they are not 
										part of the state variable and hence cannot be observed.
									</li>
								</ul>

								<br>
								
								</p>
								<center>
									<div class="work-img">
										<img src="assets/img/works/KF_constant_velocity_anim.gif" />
									</div>
									<h5 id="kalman-filter-constant-velocity-model-tracking-robot-position">kalman filter (constant velocity model) tracking
										robot position</h5>
								</center>
								
								<br>

								<p>
								<ul style="list-style-type: disc">
									<li>
										The animation above was run on 100 timestamps with data missing at
										timestamps 10, 11, 12, 30, 31, 32, 33, 34, 50, 51 and 52. The initial state was set to x=0, y=0 and theta=0,
										also the velocities of respective variables were set to 0 as seen in the plot.
									</li>
									<li>
										The predictions can be seen to overshoot at corners as we modelled our system as having constant velocity.
										At the corners the system cannot estimate that it is decelerating but just updates it position based off the
										last velocity estimate.</li>
									<li>
										At the discontinuities we can see that the robot tries to follow a linear path since we don't have position input coming in
										but just the system prediction based on last velocity estimate.
									</li>
								</ul>
								</p>

								<br>

								<center>
									<div class="work-img">
										<img src="assets/img/works/KF_constant_velocity_err.png" />
									</div>
									<h5 id="kalman-filter-constant-velocity-model-plot-of-variances-in-x-y-and-theta">kalman filter (constant velocity
										model) plot of variances in x, y and theta</h5>
								</center>
								
								<br>
								
								<p>
								<ul style="list-style-type: disc">
									<li>
										The variances at x, y and theta are plotted in the graph above. We can see that when the position data goes missing,
										the kalman filter will predict the robot position at the same time say that we have now more noise in the system
										and hence less accuracy in the estimate.
									</li>
									<li>
										These variances fall back close to zero once the measurements become available.
									</li>
									
								</ul>
								</p>


								<h3 id="kalman-filter-sensor-fusion">Kalman Filter (Sensor fusion)</h3>

								<center>
									<div class="work-img">
										<img src="assets/img/works/yo_dawg.jpg" alt="">
									</div>
									<h5 id="yo_dawg">How sensor fusion works</h5>
								</center>

								<br>

								<p>Here a kalman filter is designed that estimates the system state based on 2 sensor inputs (position sensor eg: gps
									and an acceleration sensor eg: imu)</p>
								<ol style="list-style-type: decimal">
									<li>The dynamic model here has 3 more states of the robot (acceleration in x, y and theta) as these variables need
										to be updated using the imu.
										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;X_{n}&space;=&space;\begin{bmatrix}&space;x_{n}&space;\\&space;y_{n}&space;\\&space;\theta_{n}&space;\\&space;\dot{x}_{n}&space;\\&space;\dot{y}_{n}&space;\\&space;\dot{\theta}_{n}&space;\\&space;\ddot{x}_{n}&space;\\&space;\ddot{y}_{n}&space;\\&space;\ddot{\theta}_{n}&space;\end{bmatrix}"
												title="X_{n} = \begin{bmatrix} x_{n} \\ y_{n} \\ \theta_{n} \\ \dot{x}_{n} \\ \dot{y}_{n} \\ \dot{\theta}_{n} \\ \ddot{x}_{n} \\ \ddot{y}_{n} \\ \ddot{\theta}_{n} \end{bmatrix}" />
										</center>
										<br>
									</li>
									<li>Matrix <img src="https://render.githubusercontent.com/render/math?math=A"> now has the terms for acceleration
										from equations of motion, matrix <img src="https://render.githubusercontent.com/render/math?math=B"> has terms
										for jerk (the differential of acceleration, check taylor series expansion) in this model but is not used for
										prediction since we provide no control input matrix <img
											src="https://render.githubusercontent.com/render/math?math=U">. <img
											src="https://render.githubusercontent.com/render/math?math=B"> will only be used to compute <img
											src="https://render.githubusercontent.com/render/math?math=Q"> matrix.
										<br>
										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;A&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;t&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;\\&space;\end{bmatrix}&space;\text{&space;}&space;B&space;=&space;\begin{bmatrix}&space;\frac{t^3}{6}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\frac{t^3}{6}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\frac{t^3}{6}&space;\\&space;\frac{t^2}{2}&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\frac{t^2}{2}&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\frac{t^2}{2}&space;\\&space;t&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;t&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;t&space;\end{bmatrix}"
												title="A = \begin{bmatrix} 1 & 0 & 0 & t & 0 & 0 & \frac{t^2}{2} & 0 & 0 \\ 0 & 1 & 0 & 0 & t & 0 & 0 & \frac{t^2}{2} & 0 \\ 0 & 0 & 1 & 0 & 0 & t & 0 & 0 & \frac{t^2}{2} \\ 0 & 0 & 0 & 1 & 0 & 0 & t & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & t & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & t \\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{bmatrix} \text{ } B = \begin{bmatrix} \frac{t^3}{6} & 0 & 0 \\ 0 & \frac{t^3}{6} & 0 \\ 0 & 0 & \frac{t^3}{6} \\ \frac{t^2}{2} & 0 & 0 \\ 0 & \frac{t^2}{2} & 0 \\ 0 & 0 & \frac{t^2}{2} \\ t & 0 & 0 \\ 0 & t & 0 \\ 0 & 0 & t \end{bmatrix}" />
										</center>
										<br>
									</li>
									<li>Process noise matrix <img src="https://render.githubusercontent.com/render/math?math=Q"> in this case will be
										due to neglecting jerk and other higher order differentials. hence it is given as with the diagonal terms
										accounting for noise in x, y and theta. The values of diagonals are selected as small values in range 0 to 1.
										<center>
											<br>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;Q_a&space;=&space;\begin{bmatrix}&space;\sigma_{\dddot{x}}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{\dddot{y}}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{\dddot{\theta}}^2&space;\end{bmatrix}"
												title="Q_a = \begin{bmatrix} \sigma_{\dddot{x}}^2 & 0 & 0 \\ 0 & \sigma_{\dddot{y}}^2 & 0 \\ 0 & 0 & \sigma_{\dddot{\theta}}^2 \end{bmatrix}" />
										</center>
										<br>
									</li>
									<li>Measurement model in this case has 2 sensors which perform the updates</li>
								</ol>
								<ol style="list-style-type: lower-roman">
									<li><b>Position sensor model:</b> needs matrix <img src="https://render.githubusercontent.com/render/math?math=H_{pos}">
										which has dimensions 3x9 since 3 variables are measured (x, y and theta) and the state has 9 variables.
										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;H_{pos}&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;\\&space;\end{bmatrix}"
												title="H_{pos} = \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \end{bmatrix}" />
										</center>
										<br>

										The noise model for position sensor is given as

										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;R_{pos}&space;=&space;\begin{bmatrix}&space;\sigma_{x}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{y}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{{\theta}}^2&space;\end{bmatrix}"
												title="R_{pos} = \begin{bmatrix} \sigma_{x}^2 & 0 & 0 \\ 0 & \sigma_{y}^2 & 0 \\ 0 & 0 & \sigma_{{\theta}}^2 \end{bmatrix}" />
										</center>
										<br>
									</li>
								
									<li><b>IMU sensor model:</b> needs matrix <img src="https://render.githubusercontent.com/render/math?math=H_{imu}"> which
										has dimensions 3x9 since 3 variables are measured, acceleration in x, y and theta and the state has 9 variables.
										<br>
										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;H_{imu}&space;=&space;\begin{bmatrix}&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;0&space;&&space;1&space;\\&space;\end{bmatrix}"
												title="H_{imu} = \begin{bmatrix} 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \end{bmatrix}" />
										</center>
										<br>
										The noise model for IMU is given as
										<center>
											<img src="https://latex.codecogs.com/png.latex?\dpi{150}&space;R_{imu}&space;=&space;\begin{bmatrix}&space;\sigma_{\ddot{x}}^2&space;&&space;0&space;&&space;0&space;\\&space;0&space;&&space;\sigma_{\ddot{y}}^2&space;&&space;0&space;\\&space;0&space;&&space;0&space;&&space;\sigma_{\ddot{\theta}}^2&space;\end{bmatrix}"
												title="R_{imu} = \begin{bmatrix} \sigma_{\ddot{x}}^2 & 0 & 0 \\ 0 & \sigma_{\ddot{y}}^2 & 0 \\ 0 & 0 & \sigma_{\ddot{\theta}}^2 \end{bmatrix}" />
										</center>
									</li>
								</ol>
								
								<ol start="5" style="list-style-type: decimal">
									<li>The measurement matrices above <img src="https://render.githubusercontent.com/render/math?math=H_{pos}">, <img
											src="https://render.githubusercontent.com/render/math?math=R_{pos}"> are used to update the kalman filter
										when position inputs are available to the kalman filter, Matrices <img
											src="https://render.githubusercontent.com/render/math?math=H_{imu}">, <img
											src="https://render.githubusercontent.com/render/math?math=R_{imu}"> are used when imu data is available.
										Given these updates the kalman filter can work asynchronously to update the state when a sensor measurement is
										available.</li>
								</ol>

								<br>

								<center>
									<div class="work-img">
										<img src="assets/img/works/KF_fusion_anim.gif" />
									</div>
									<h5 id="kalman-filter-sensor-fusion-model-tracking-robot-position">kalman filter (sensor fusion model) tracking robot
										position</h5>
								</center>

								<br>

								<p>*<a href="WD-kalman-filter.html#anim_key">animation legend</a> to understand the plots*</p>

								<p>
								<ul style="list-style-type: disc">
									<li>
										The animation above was run on 100 timestamps with position data missing at
										timestamps 10, 11, 12, 30, 31, 32, 33, 34, 50, 51 and 52, while acceleration data missing at
										20, 21, 22, 30, 31, 33 and 34. The initial state was set to x=0, y=0 and theta=0, also
										the velocities and accelerations of respective variables were set to 0.
									</li>
									<li>
										The predictions now don't overshoot at the corners as we modelled our system accounting the acceleration.
										At the corners the system can now react to the deceleration being measured from the imu sensor.
									</li>
									<li>
										At the discontinuities for position we can see that the robot deviates less from the actual path as we still have an acceleration
										input coming from the imu sensor.
									</li>
									<li>
										When acceleration data is missing it can be seen that the robot is still able to keep track of its position 
										as we have gps data coming in. Although the acceleration slightly deviates from the ideal value.
									</li>
									<li>
										Thus from the above animation we can conclude that having multiple sensors on the system not only improves 
										the overall position estimate but also helps when one of the sensor is not receiving data (eg: say when a car enters the 
										tunnel when we lose gps but the onboard imu and wheel encoders can still help us track its position till we are out
										of the tunnel).
									</li>
								</ul>
								</p>

								<center>
									<div class="work-img">
										<img src="assets/img/works/KF_fusion_err.png" />
									</div>
									<h5 id="kalman-filter-sensor-fusion-model-plot-of-variances-in-x-y-and-theta">kalman filter (sensor fusion model) plot
										of variances in x, y and theta</h5>
								</center>

								<br>

								<p>
								<ul style="list-style-type: disc">
									<li>
										The variances at x, y and theta are plotted in the graph above. When the position data goes missing, the
										variance increases and
										falls right back when new position data is available.
									</li>
									<li>
										When both sensors are switched off individually at different times we can see that the estimate doesn't gather a lot of noise,
										except when both sensors are both switched off at timestamps 30, 31, 33 and 34 we see that the noise (covariance) increases.
									</li>
								</ul>
								</p>
								

								<h3 id="experiments">Experiments</h3>

								<p>
									In this section we do some experiments with the sensor fusion version of the kalman filter discussed above.
								</p>

								<br>

								<ol style="list-style-type: decimal">

									<li>
										We switch off the imu sensor (acceleration) after 20 timestamps (in real life this could be a failing sensor). The position
										sensor does keep sending synchronous inputs to the system. The initial state was set to x=0, y=0 and theta=0, also the velocities and accelerations
										of respective variables were set to 0.

										<br>

										<center>
											<div class="work-img">
												<img src="assets/img/works/KF_DR_no_acc_anim.gif" />
											</div>
											<h5
												id="kalman-filter-sensor-fusion-model-tracking-robot-position-with-position-input-only-imu-switched-off-at-20-iterations">
												kalman filter (sensor fusion model) tracking robot position with position input only (imu switched off at 20
												iterations)</h5>
										</center>
										
										<br>
										
										<p>
										<ul style="list-style-type: disc">
											<li>
												From the animation we can see that the kalman filter is able to function even though the acceleration input is
												not available to the system and does a very good job in estimating the acceleration of the robot.
											</li>
											<li>
												The acceleration estimate is slightly delayed compared to the true value.
											</li>
										</ul>
										</p>

										<br>

										<center>
											<div class="work-img">
												<img src="assets/img/works/KF_DR_no_acc_err.png" />
											</div>
											<h5 id="kalman-filter-sensor-fusion-model-plot-of-variances-in-x-y-and-theta-1">kalman filter (sensor fusion model)
												plot
												of variances in x, y and theta</h5>
										</center>

										<br>

										<p>
										<ul style="list-style-type: disc">
											<li>
												From the noise estimates of the system it can be seen that the values are slightly higher than actual sensor fusion
												model.
											</li>
											<li>
												At the corners we can see that the noise levels increase which corresponds to the delayed acceleration estimates.
											</li>
											<font size="-1">*I suggest touching your nose to the screen at value 50 on the variance(y) graph and moving back you head slowly till
											you notice the changes in values ;-)*</font>
										</ul>
										</p>

									</li>

									<br>
									
									<li>
										We switch off the position sensor (gps) after 20 timestamps (in real life this could be a failing sensor or a car going
										into a tunnel losing gps signal). The imu sensor does keep sending synchronous inputs to the system.
										The initial state was set to x=0, y=0 and theta=0, also the velocities and accelerations of respective variables were
										set to 0.

										<center>
											<div class="work-img">
												<img src="assets/img/works/KF_DR_no_pos_anim.gif" />
											</div>
											<h5 id="kalman-filter-sensor-fusion-model-dead-reckoning-position-sensor-switched-off-at-20-iterations">kalman
												filter
												(sensor fusion model) dead reckoning (position sensor switched off at 20 iterations)</h5>
										</center>

										<br>

										<ul style="list-style-type: disc">
											<li>
												From the animation we can see that the kalman filter is not able to track the robot right after the position sensor
												stops sending in data. The estimates do resemble a sine curve as we have acceleration still coming in from the
												imu.
											</li>
											<li>
												The initial offset just before the position sensor switched off will be almost constant in the system as is seen
												from the graph.
											</li>
											<li>
												This is called dead reckoning where we try to calculate the robots current position using the previously computed
												position and looks like the following.
											</li>
										</ul>

										<br>

										<center>
											<div class="work-img">
												<img src="assets/img/works/dead_reckoning_meme.jpg" />
											</div>
											<h5 id="how dead reckoning looks like:- you can feel it but you cant see it">
												how dead reckoning looks like
											</h5>
										</center>

										<br>
										
										<center>
											<div class="work-img">
												<img src="assets/img/works/KF_DR_no_pos_err.png" alt="">
											</div>
											<h5 id="kalman-filter-sensor-fusion-model-plot-of-variances-in-x-y-and-theta-2">kalman filter (sensor fusion model)
												plot
												of variances in x, y and theta</h5>
											<!-- <img src="assets/img/works/KF_DR_no_pos_err.png" /> -->
										</center>

										<br>

										<p>
										<ul style="list-style-type: disc">
											<li>
												To compute the position, the acceleration value is integrated twice and hence the noise values add up in the system
												as can be seen from the variance.
											</li>
											<li>
												The errors also rise exponentially immediately after the position sensor is switched off. Which is a good sign 
												that our robot knows its position estimates are incorrect.
											</li>
											<font size="-1">*I think I am in london but I'm not sure I might just be in UK ;-)*</font>
										</ul>
										</p>

									</li>

								</ol>

								<h3 id="design-notes">Design notes</h3>
								<ol style="list-style-type: decimal">
									<li>The Q matrix values should be selected as a value between 0 and 1. the values can be tuned looking at system
										outputs. The general intuition for Q is, higher the values the less system will trust its prediction as compared
										to measurements. Q diagonals cannot be set to 0 as this will imply a perfect system giving kalman gain 0 and
										hence the system will no longer update itself based on measurements rather trust its predictions fully.</li>
									<li>The R matrix can be experimentally determined by taking a standard deviation of the error between sensor
										measurements and true values. This requires a true measurement to be available of the measured quantity, apart
										from what is measured by the sensor.</li>
									<li>Multiple sensors can be fused using the kalman filter given the H and R matrices for those sensors. An update
										step can be performed when any of the sensor measurements are available. Hence using this design the kalman
										filter can run at a maximum frequency which is the frequency of the slowest sensor.</li>
								</ol>



								<h3 id="design-notes">References</h3>
								<ol style="list-style-type: decimal">
									<li>
										These <a href="https://www.youtube.com/watch?v=CaCcOwJPytQ&list=PLX2gX-ftPVXU3oUFNATxGXY90AULiqnWT">Youtube lecture series</a> 
										by Michel van Biezen.
									</li>
									<li>
										<a href="https://www.kalmanfilter.net/kalman1d.html">Website</a>
										with clear explanation of the single dimensional kalman filter.
									</li>
									<li>
										LinkedIn <a href="https://www.linkedin.com/pulse/2d-object-tracking-tutorial-kalman-filter-matlab-code-al-ahdab">tutorial</a>
										by Mohammad Al-Ahdab.
									</li>
								</ol>
								
							</div>
							<div class="sharebox__module awe-text-center">
								<p class="social-text">SHARE THIS WORK</p>
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-facebook"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-twitter"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-linkedin"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-behance"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-vimeo"></i>
								</a><!-- End / social-icon -->
								
							</div>
						</div><!-- End /  -->
						
						<div class="awe-text-center mt-50">
							<a class="md-btn md-btn--outline-primary " href="#">All work
							</a>
						</div>
					</div>
				</section>
				<!-- End / Section -->
				
			</div>
			<!-- End / Content-->
			
			<!-- footer -->
			<div class="footer">
				<div class="container">
					<div class="row">
						<div class="col-md-6 col-lg-6 ">
							<p class="footer__coppy">2018 &copy; Copyright <a href="http://awe7.com/">Awe7</a>. All rights Reserved.</p>
						</div>
						<div class="col-md-6 col-lg-6 ">
							<div class="footer__social">
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-facebook"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-twitter"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-linkedin"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-behance"></i>
								</a><!-- End / social-icon -->
								
								
								<!-- social-icon -->
								<a class="social-icon" href="#"><i class="social-icon__icon fa fa-vimeo"></i>
								</a><!-- End / social-icon -->
								
							</div>
						</div>
					</div>
				</div>
			</div><!-- End / footer -->
			
		</div>
		<!-- Vendors-->
		<script type="text/javascript" src="assets/vendors/jquery/jquery.min.js"></script>
		<script type="text/javascript" src="assets/vendors/imagesloaded/imagesloaded.pkgd.js"></script>
		<script type="text/javascript" src="assets/vendors/isotope-layout/isotope.pkgd.js"></script>
		<script type="text/javascript" src="assets/vendors/jquery-one-page/jquery.nav.min.js"></script>
		<script type="text/javascript" src="assets/vendors/jquery.easing/jquery.easing.min.js"></script>
		<script type="text/javascript" src="assets/vendors/jquery.matchHeight/jquery.matchHeight.min.js"></script>
		<script type="text/javascript" src="assets/vendors/magnific-popup/jquery.magnific-popup.min.js"></script>
		<script type="text/javascript" src="assets/vendors/masonry-layout/masonry.pkgd.js"></script>
		<script type="text/javascript" src="assets/vendors/jquery.waypoints/jquery.waypoints.min.js"></script>
		<script type="text/javascript" src="assets/vendors/swiper/swiper.jquery.js"></script>
		<script type="text/javascript" src="assets/vendors/menu/menu.js"></script>
		<script type="text/javascript" src="assets/vendors/typed/typed.min.js"></script>
		<!-- App-->
		<script type="text/javascript" src="assets/js/main.js"></script>
	</body>
</html>